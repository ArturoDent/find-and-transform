function _findSettingRange(index, settingsText, document) {

	const re = /({)|(})/;
	let brackets = 0;
	// let offset = index;
	let offset = 0;
	let match;

	// count braces until matching closing brace; will be end of this setting
	do {
		match = settingsText.match(re);
		if (match[0] === '{') ++brackets;
		if (match[0] === '}') --brackets;

		if (brackets) {
			offset += match.index + 1;
			settingsText = settingsText.substring(match.index + 1);
		}
		else offset += match.index;
	} while (brackets);

	/** @type { vscode.Position } */
	let settingStartPos;
	let settingEndPos;

	if (index) {
		settingStartPos = document.positionAt(index);  // start of setting
		settingEndPos = document.positionAt(index + offset);  // end of setting
	}
	else return undefined;

	return new vscode.Range(settingStartPos, settingEndPos);
}

---------------------------------------------------------------------------------------

/**
 * Replace all find matches in the entire document
 *
 * @param {vscode.window.activeTextEditor} editor
 * @param {vscode.TextEditorEdit} edit
 * @param {String} findValue
 * @param {String} replaceValue
 */
function _replaceWholeDocument(editor, edit, findValue, replaceValue) {

	const re = new RegExp(findValue, "gm");
	const firstLine = editor.document.lineAt(0);
	const lastLine = editor.document.lineAt(editor.document.lineCount - 1);
	const matchRange = new vscode.Range(firstLine.range.start, lastLine.range.end);

	let docString = editor.document.getText();
	let doReplace = false;

	if (re.test(docString)) {  // boolean, must be a global regexp

		doReplace = true;
		// find all matches in iteratively reduced docString
		docString = docString.replace(re, (...groups) => {
			return _buildReplaceValue(replaceValue, groups);
		});
	};
	if (doReplace) edit.replace(matchRange, docString);
}